jenkinsfile.java
--------------------


#!groovy

pipeline {
  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    disableConcurrentBuilds()
	ansiColor('xterm')
  }
  environment {
     NEXUS_USERNAME = credentials('NEXUS_USERNAME')
     NEXUS_PASSWORD = credentials('NEXUS_PASSWORD')
     GIT_USERNAME = credentials('GIT_USERNAME')
     GIT_PASSWORD = credentials('GIT_PASSWORD')
	 }
  agent {label 'primary-slave'}
  stages {
    stage('Build') {
      steps {
        script {
          sh '''
            SBI/build.sh
          '''
        }
      }
    }
    stage('Test') {
      steps {
        script {
          sh '''
            SBI/test.sh
          '''
        }
      }
    }
    stage('Checkstyle') {
      steps {
        step([$class: 'CheckStylePublisher',
          canRunOnFailed: true,
          defaultEncoding: '',
          pattern: '**/checkstyle-*.xml',
          healthy: '',
          unHealthy: '',
          useStableBuildAsReference: true
        ])
      }
    }
	stage('Jacoco') {
     when {
        expression {
          fileExists("target/site/cobertura/coverage.xml") ||  \
		  fileExists("target/site/cobertura/digital-coverage.xml")
        }
      }
   steps {
      step([$class: 'CoberturaPublisher',
                autoUpdateHealth: false,
                autoUpdateStability: false,
                coberturaReportFile: 'target/site/cobertura/*.xml',
                failUnhealthy: false,
                failUnstable: false,
                maxNumberOfBuilds: 0, onlyStable: false, sourceEncoding: 'ASCII',
                zoomCoverageChart: false
               ])
          }
    }
    stage('Container Build') {
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/dockerize.sh")
        }
      }
      steps {
        script {
          sh '''
            SBI/dockerize.sh
          '''
        }
      }
    }
    stage('Deploy') {
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/service-manifest.txt")
        }
      }
      steps {
        script {
          def services = readFile('SBI/service-manifest.txt').readLines()
          for (int i = 0; i < services.size(); i++) {
            def fields = services[i].split( ':' )
            if (fields.size() == 2) {
              def (service,type) = fields
              def jobname = 'Deployment/Deploy ' + type + ' Service'
              println('Deploying via ' + jobname + ' for service ' + service)
              build job: jobname,
                parameters: [
                  string(name: 'BRANCH', value: env.BRANCH_NAME),
                  string(name: 'SERVICE', value: service)
                ],
                wait: false
            } else {
              println('Skipping invalid service manifest entry: ' + services[i])
            }
          }
        }
      }
    }
  }
  post {
    always {
      script {
        currentBuild.result = currentBuild.currentResult
		sh '''
        if  [ -f build_fail.log ];then
        tail -50 build_fail.log  >> build_fail.txt && rm -f build_fail.log && mv build_fail.txt build_fail.log && \
        rm -f build_fail.log-txt* && unix2dos -f build_fail.log
        fi
        '''
      }
    }
	success {
    script {
	if (fileExists('scan_status.log')) {
      env.SCAN_STATUS = readFile('scan_status.log').trim()
      if (env.SCAN_STATUS == 'fail') {
         emailext (attachmentsPattern: 'scan_report.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true,
                subject: "Build failed in Jenkins due to image scan failure: ${currentBuild.fullDisplayName}",
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
          }
       }
    }
	}
    fixed {
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Jenkins build back to normal: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
    failure {
      // notify users when the Pipeline fails
	  script {
        if (fileExists('build_fail.log')) {
         emailext (attachmentsPattern: 'build_fail.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true, 
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
	      }else
        {
		  emailext (attachLog: true,
                body: "${currentBuild.result}: ${BUILD_URL}",// compressLog: true, 
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
	}
	}
    unstable {
      // notify users when the Pipeline unstable
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Unstable Pipeline: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
  }
}




Jenkins.python
--------------------------

#!groovy

pipeline {
  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    disableConcurrentBuilds()
    ansiColor('xterm')
  }
  environment {
	 RDSHFT_HOST = credentials('RDSHFT_HOST')
     RDSHFT_USER = credentials('RDSHFT_USER')
     RDSHFT_PASS = credentials('RDSHFT_PASS')
     RDSHFT_NAME = credentials('RDSHFT_NAME')
     NEXUS_USERNAME = credentials('NEXUS_USERNAME')
     NEXUS_PASSWORD = credentials('NEXUS_PASSWORD')
	 }
  agent {label 'primary-slave'}
  stages {
    stage('Build') {
      steps {
        script {
          sh '''
            SBI/build.sh
          '''
        }
      }
    }
    stage('Test') {
      steps {
        script {
          sh '''
            SBI/test.sh
          '''
        }
      }
    }
    stage('Clover') {
     when {
        expression {
          fileExists("./clover.xml")
        }
      }
      steps {
        step([
          $class: 'CloverPublisher',
          cloverReportDir: '.',
          cloverReportFileName: 'clover.xml',
          healthyTarget: [methodCoverage: 70, conditionalCoverage: 80, statementCoverage: 80], // optional, default is: method=70, conditional=80, statement=80
        ])
      }
    }
    stage('Checkstyle') {
      steps {
        step([$class: 'CheckStylePublisher',
          canRunOnFailed: true,
          defaultEncoding: '',
          pattern: '**/checkstyle-*.xml',
          healthy: '',
          unHealthy: '',
          useStableBuildAsReference: true
        ])
      }
    }
    stage ('Publish HTML Report') {
     when {
        expression {
          fileExists("htmlcov/index.html")
        }
      } 
      steps {
        // publish html
        publishHTML target: [
            allowMissing: false,
            alwaysLinkToLastBuild: false,
            keepAll: true,
            reportDir: 'htmlcov',
            reportFiles: 'index.html',
            reportName: 'HTML Report'
          ]
      }
    }
    stage('Publish Cobertura Report') {
     when {
        expression {
          fileExists("./coverage.xml")
        }
      }
      steps {
        step([$class: 'CoberturaPublisher', 
                autoUpdateHealth: false, 
                autoUpdateStability: false, 
                coberturaReportFile: '**/coverage.xml', 
                failUnhealthy: false, 
                failUnstable: false, 
                maxNumberOfBuilds: 0, onlyStable: false, sourceEncoding: 'ASCII', 
                zoomCoverageChart: false
               ])
          } 
    }
    stage('TAP') {
      steps {
        step([$class: "TapPublisher", testResults: "jenkins-test-results/*.tap"])
      }
    }
    stage('Container Build') {
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/dockerize.sh")
        }
      }
      steps {
        script {
          sh '''
            SBI/dockerize.sh
          '''
        }
      }
    }
    stage('Deploy') {
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/service-manifest.txt")
        }
      }
      steps {
        script {
          def services = readFile('SBI/service-manifest.txt').readLines()
          for (int i = 0; i < services.size(); i++) {
            def fields = services[i].split( ':' )
            if (fields.size() == 2) {
              def (service,type) = fields
              def jobname = 'Deployment/Deploy ' + type + ' Service'
              println('Deploying via ' + jobname + ' for service ' + service)
              build job: jobname,
                parameters: [
                  string(name: 'BRANCH', value: env.BRANCH_NAME),
                  string(name: 'SERVICE', value: service)
                ],
                wait: false
            } else {
              println('Skipping invalid service manifest entry: ' + services[i])
            }
          }
        }
      }
    }
  }
  post {
    always {
      script {
        currentBuild.result = currentBuild.currentResult
	    sh '''
        if  [ -f build_fail.log ];then
        tail -50 build_fail.log  >> build_fail.txt && rm -f build_fail.log && mv build_fail.txt build_fail.log && \
        unix2dos -f build_fail.log
        if [ -f build_fail.log-txt ];then rm -f build_fail.log-txt;fi
        fi
        '''
      }
    }
    success {
    script {
	if (fileExists('scan_status.log')) {
      env.SCAN_STATUS = readFile('scan_status.log').trim()
      if (env.SCAN_STATUS == 'fail') {
         emailext (attachmentsPattern: 'scan_report.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true,
                subject: "Build failed in Jenkins due to image scan failure: ${currentBuild.fullDisplayName}",
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
          }
       }
    }
	}
    fixed {
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Jenkins build back to normal: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
    failure {
      // notify users when the Pipeline fails
      script {
        if (fileExists('build_fail.log')) {
         emailext (attachmentsPattern: 'build_fail.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true,
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}",
               recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
          }else
        {
          emailext (attachLog: true,
                body: "${currentBuild.result}: ${BUILD_URL}",// compressLog: true,
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}",
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
    }
    }
    unstable {
      // notify users when the Pipeline unstable
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Unstable Pipeline: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
  }
}


jenkinfile.node...
---------------------------------

#!groovy

pipeline {
  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    disableConcurrentBuilds()
    ansiColor('xterm')
  }
  agent {label 'primary-slave'}
  stages {
    
    stage('Build') {
      steps {
        script {
          sh '''
            SBI/build.sh
          '''
        }
      }
    }
    stage('Test') {
      steps {
        script {
          sh '''
            SBI/test.sh
          '''
        }
      }
    }
    stage('Clover') {
       
      when {
        expression {
          fileExists("jenkins-test-results/clover.xml")
        }
      }
      steps {
        step([
          $class: 'CloverPublisher',
          cloverReportDir: 'jenkins-test-results',
          cloverReportFileName: 'clover.xml',
          healthyTarget: [methodCoverage: 70, conditionalCoverage: 80, statementCoverage: 80], // optional, default is: method=70, conditional=80, statement=80
        ])
      }
    }
    stage('Checkstyle') {
       
      steps {
        step([$class: 'CheckStylePublisher',
          canRunOnFailed: true,
          defaultEncoding: '',
          pattern: '**/checkstyle-*.xml',
          healthy: '',
          unHealthy: '',
          useStableBuildAsReference: true
        ])
      }
    }
    stage('TAP') {
       
      steps {
        step([$class: "TapPublisher", testResults: "jenkins-test-results/*.tap"])
      }
    }
    stage('Container Build') {
       
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/dockerize.sh")
        }
      }
      steps {
        script {
          sh '''
            SBI/dockerize.sh
          '''
        }
      }
    }
    stage('Deploy') {
       
      when {
        environment name: 'CHANGE_ID', value: ''
        expression {
          fileExists("SBI/service-manifest.txts")
        }
      }
      steps {
        script {
          def services = readFile('SBI/service-manifest.txt').readLines()
          for (int i = 0; i < services.size(); i++) {
            def fields = services[i].split( ':' )
            if (fields.size() == 2) {
              def (service,type) = fields
              def jobname = 'Deployment/Deploy ' + type + ' Service'
              println('Deploying via ' + jobname + ' for service ' + service)
              build job: jobname,
                parameters: [
                  string(name: 'BRANCH', value: env.BRANCH_NAME),
                  string(name: 'SERVICE', value: service)
                ],
                wait: false
            } else {
              println('Skipping invalid service manifest entry: ' + services[i])
            }
          }
        }
      }
    }
  }
  post {
    always {
      script {
        currentBuild.result = currentBuild.currentResult
		sh '''
        if  [ -f build_fail.log ];then
        tail -100 build_fail.log  >> build_fail.txt && rm -f build_fail.log && mv build_fail.txt build_fail.log && \
        rm -f build_fail.log-txt* && unix2dos -f build_fail.log
        fi
        '''
      }
    }
    success {
    script {
	if (fileExists('scan_status.log')) {
      env.SCAN_STATUS = readFile('scan_status.log').trim()
      if (env.SCAN_STATUS == 'fail') {
         emailext (attachmentsPattern: 'scan_report.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true,
                subject: "Build failed in Jenkins due to image scan failure: ${currentBuild.fullDisplayName}",
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
          }
       }
    }
	}
    fixed {
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Jenkins build back to normal: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
    failure {
      // notify users when the Pipeline fails
      script {
        if (fileExists('build_fail.log')) {
         emailext (attachmentsPattern: 'build_fail.log',
                body: "${currentBuild.result}: ${BUILD_URL}", //compressLog: true,
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}",
               recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
          }else
        {
          emailext (attachLog: true,
                body: "${currentBuild.result}: ${BUILD_URL}",// compressLog: true,
                subject: "Build failed in Jenkins: ${currentBuild.fullDisplayName}",
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
    }
    }
    unstable {
      // notify users when the Pipeline unstable
      emailext (attachLog: true, body: "${currentBuild.result}: ${BUILD_URL}", compressLog: true, 
                subject: "Unstable Pipeline: ${currentBuild.fullDisplayName}", 
                recipientProviders: [[$class: 'CulpritsRecipientProvider'],[$class: 'RequesterRecipientProvider']],
                to: 'RCXHydTeam@rythmos.com')
    }
  }
}
